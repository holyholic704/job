## Java 概述

* JDK：Java Development Kit，Java 开发工具包，提供了 Java 的开发环境和运行环境

* JRE：Java Runtime Environment，Java 运行环境，为 Java 的运行提供了所需环境

* SE：Standard Edition，标准版，用于桌面或简单服务器应用的 Java 平台

* EE：Enterprise Edition，企业版，用于复杂服务器应用的 Java 平台

### Java 特点

简单性、面向对象、分布式、健壮性、安全性、体系结构中立、可移植性、解释型、高性能、多线程、动态性

### Java 跨平台原理

Java 程序不是直接在电脑上运行的，**是在虚拟机上运行的，JVM 也是一个软件**，不同的平台有不同的版本。JVM 就是负责将字节码文件翻译成特定平台下的机器码然后运行。Java 代码首先被编译成字节码文件，再由 JVM 将字节码文件翻译成机器语言。**字节码不能直接运行，必须通过 JVM 翻译成机器码才能运行**。不同平台下编译生成的字节码是一样的，但是由 JVM 翻译成的机器码却不一样。即使将 Java 程序打包成可执行文件，仍然需要 JVM 的支持。**跨平台的是 Java 程序，不是 JVM**，JVM 是用 C/C++ 开发的，是编译后的机器码，不能跨平台，不同平台下需要安装不同版本的 JVM

#### JVM

当我们运行一个程序时，JVM 负责将字节码转换为特定机器代码，JVM 提供了内存管理、垃圾回收和安全机制等。这种独立于硬件和操作系统，正是 Java 程序可以一次编写多处执行的原因

## 数据类型

Java 语言是强类型语言，不同的数据类型，在内存中分配了不同大小的内存空间。在定义变量的时候，声明这个变量的数据类型，就会给这个变量开辟一块合理大小的内存区域，可以合理的分配内存空间，从而避免空间浪费

### 基本类型与引用类型

基本类型：**保存在栈内存中的简单数据段**，即这种值完全保存在内存中的一个位置

引用类型：**保存在堆内存中的对象**，即变量中保存的实际是对象的内存地址

### 八大基本数据类型

![20190510160015](../md.assets/20190510160015.png)

八种基本数据类型 **除 boolean 类型之外都可以相互转换**。byte、short、char 做混合运算的时候，会先转换成 int 再做运算。多种数据类型做混合运算，先转换成容量最大的那种再做运算。在 Java 语言里面除了基本数据类型，其他的都是引用数据类型

#### char 类型变量中能不能存储一个中文汉字

char 类型变量是用来存储 Unicode 编码的字符的，Unicode 编码字符集中包含了汉字。Unicode 类编码占用两个字节，所以，char 类型的变量也是占用两个字节

#### short s1 = 1，s1 = s1 + 1 与 short s1 = 1，s1 += 1

* `short s1 = 1;s1 = s1 + 1`：由于 `s1+1` 运算时 **会自动提升表达式的类型**，所以结果是 int 型，再赋值给 short 类型 s1 时，编译器将报告需要强制转换类型的错误

* `short s1 = 1;s1 += 1`：`+=` 是 Java 语言规定的运算符，Java 编译器会对它进行特殊处理，因此可以正确编译

### 五种引用数据类型

类、接口类型、数组类型、枚举类型、注解类型

### 参数传递

Java 中方法参数传递方式是 **按值传递**。基本类型，传递的是基本类型的字面量值的拷贝，不改变其值。引用类型，传递的是该参量所引用的对象在堆中地址值的拷贝，改变其值

String 类虽然是引用数据类型，但它做参数传递时和基本数据类型是一样的

*更多：[Java 到底是值传递还是引用传递](https://www.zhihu.com/question/31203609)*

## 运算符

### && 和 & 的区别

&& 具有短路效果。如果左边结果是 false，则右边不执行

& 是无论左边是 false 还是 true，右边都会执行

### ^ 逻辑异或

逻辑异或，两边只要是不一致就是 true

 ### = 赋值运算符

基本类型，赋值运算符会直接改变变量的值，原来的值被覆盖掉
引用类型，赋值运算符会改变引用中所保存的地址，原来的地址被覆盖掉。**但是原来的对象不会被改变**

### 移位运算符

* `<<`：左移运算符，`num << 1`，相当于 num 乘以 2
* `>>`：右移运算符，`num >> 1`，相当于 num 除以 2

* `>>> `：无符号右移，忽略符号位，空位都以 0 补齐

```java
// 以下数据类型为int
 7：00000000000000000000000000000111
// -7的二进制为7的反码加上补码1，正数的原码、反码、补码相同
-7：11111111111111111111111111111001    //末尾1表示-1，0表示-2

  7<<1：00000000000000000000000000001110		//结果为14
  7>>1：00000000000000000000000000000011		//结果为3
 -7<<1：11111111111111111111111111110010		//结果为-14
 -7>>1：11111111111111111111111111111100		//结果为-4
-7>>>1：01111111111111111111111111111100		//结果为2147483644
```

### 三元运算符

`布尔表达式 : 值1 ? 值2`：表达式为 true，返回值1，表达式为 false，返回值2

### == 与 equals()

* ==：**基本数据类型比较的是值，引用数据类型比较的是内存地址**

* equals()：没有被重写，比较的是内存地址；被重写，则比较两个对象内容是否相等
  * String、Integer 等中的 equals 方法是被重写过的，因为 Object 的 equals 方法是比较的对象的内存地址，而 String 的 equals 方法比较的是对象的值

## 控制语句

### switch

switch 后面的括号中可以填写 byte、short、char、int 类型，即能够自动转换为 int 类型的都可以，在 JDK7 版本之后可以填写 String 类型。**case 后面只能是常量**，不能是变量，case 的值不能重复

### while

while 循环本质上和 for 循环是一样的，可以相互替换，作用相同，格式不同，实际工作中建议使用 for 循环，因为变量会及早的从内存中消失，可以提高内存的使用效率

### break、continue、return 区别

* break：跳出一层循环，可以控制结束嵌套循环
* continue：结束一趟循环，也可以像 break 那样加上循环的名字
* return：它的作用不是结束循环的，而是结束方法

## 面向对象

### 面向过程和面向对象

* 面向过程：将问题分解成一个一个步骤，对每个步骤进行相应的抽象，形成对象，通过不同对象之间的调用，组合解决问题
  * 注重过程，把问题分解成多个不同的步骤，然后把各个步骤变成方法，使用的时候依次调用
* 易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统更加灵活、更加易于维护
* 面向对象：把问题分解成一个一个步骤，每个步骤用函数实现，依次调用即可
  * 注重对象之间的交互，将复杂的事情简单化，把问题分解成各个对象，然后各个对象之间进行交互，每个对象内部都进行了封装
  * 性能比面向对象高，类调用时需要实例化，开销比较大，比较消耗资源。没有面向对象易维护、易复用、易扩展

### 类、对象、方法

* 类是具有相同属性和方法的一组对象的集合

* 对象是系统中描述客观事物的一个实体

* 方法是指为了完成某个任务，对象所能执行的操作，可以提高代码的复用性
  * 不要在两个方法里面互相调用，程序会报出 StackOverflowError 错误
  * 方法自己调用自己叫做递归，必须要有结束条件，否则将会造成 StackOverflowError 错误

### 包

在类名前面使用关键字 package 加入包名来避免命名冲突问题，通常使用倒写的域名命名

* package 语句只能出现在 Java 文件的第一行，且只能有一个

* 如果没有 package，默认表示无包名

* Java.lang 包下所有类不需要手动导入，系统自动导入，Object类，String类都在这个包里面

### 权限修饰符

可以限定其他类对该类、属性和方法的使用权限

|  修饰符   | 同一个类 | 同一个包 | 子类 | 其他包 |
| :-------: | :------: | :------: | :--: | :----: |
|  public   | 〇 |    〇    |  〇  |   〇   |
| protected |    〇    | 〇 | 〇 | X |
|  default  |    〇    | 〇 | X | X |
|  private  |    〇    | X | X | X |

* **protected 和 private 不能用于修饰类**

### 成员变量与局部变量

* 成员变量：写在类里面，方法体的外面，声明时可以不进行初始化值，会自动以类型的默认值而赋值，可以被本类或其他类的方法进行调用，可以被访问控制修饰符及 static 所修饰，存在于堆内存，随着对象的创建而存在
* 局部变量：写在方法体的里面，声明时必须进行初始化，只能在声明局部变量的方法内进行调用，不能被访问控制修饰符及 static 所修饰，存在于栈内存，随着方法的调用而自动消失

## 重载与重写

### 方法重载（Overload）

* 发生在同一个类中

* 方法名相同，参数列表不同

* 与方法返回值类型、修饰符无关

### 方法重写（Override）

* 必须是继承关系的两个类
* 必须具有 **相同的方法名、返回值类型和参数列表**
* 重写的方法 **不能比被重写的方法拥有更低的访问权限，抛出更宽泛的异常**
* 私有方法、构造方法不能被重写
* 静态的方法不存在重写
* 重写指的是成员方法，和成员变量无关

### 为什么不能根据返回类型来区分重载

因为调用时不能指定类型信息，编译器不知道你要调用哪个函数

```java
// 当执行method(1,2)时，无法确定调用哪个方法
String method(int a, int b);
double method(int a, int b);
```

### 能否重写一个 private 或 static 的方法

* 不能重写私有方法，因为 private 修饰的变量和方法只能在当前类中使用，其他的类访问是不到。
* 静态方法不能被重写，因为方法重写是基于运行时动态绑定的，而静态方法是编译时就静态绑定的。静态方法跟类的任何实例都不相关

## This 与 Super

### This

代表着对当前对象的引用，在堆内存中的每个 Java 对象上都有一个 this 指向自己

#### This 的作用

* 可以使用 **`this.方法名`** 的方式调用当前对象的方法
* 可以区分成员变量和局部变量，使用 this 调用成员变量
* 如果要是使用 this 调用构造方法的话，那么 this **必须出现在构造方法的第一行**

### Super

代表的是当前子类对象中的父类型特征

#### Super 的作用

* 子类重写了父类的某个方法，可以使用 **`this.方法名`** 的方式调用父类方法

* 子类和父类中都有某个数据，可以使用使用 super 调用父类的数据

* 子类调用父类中的构造方法时，需要使用 super。一个构造方法第一行如果没有 this()，也没有显示的去调用super()，**系统会默认调用 super()**，如果已经有 this 了，那么就不会调用 super 了，**super 只能放在构造方法的第一行**。只是调用了父类中的构造方法，**并不会创建父类的对象**

### Super 与 This 的区别

|       |   调用成员变量   |   调用构造方法   |   调用成员方法   |
| :---: | :--------------: | :--------------: | :--------------: |
| this  | 调用本类成员变量 | 调用本类构造方法 | 调用本类成员方法 |
| super | 调用父类成员变量 | 调用父类构造方法 | 调用父类成员方法 |

## static

* 可以修饰变量
  * 被修饰的变量叫做静态变量，程序运行时静态变量存放在方法区里面

* 可以修饰方法
  * 被修饰的方法叫做静态方法，**不用创建对象就能直接访问该方法**。静态方法不能直接访问非静态的数据，静态方法不能使用 this 和 super

* 可以定义静态语句块
  * 静态语句块在类加载阶段执行，并且只执行一次，并且是自上而下的顺序执行，在构造方法之前执行

* 被修饰的变量、方法、代码块都是属于 **类级别** 的，跟对象无关。可以通过 **`类名.静态方法名 `** 的方式访问

### 静态变量与实例变量

* 语法定义上的区别
  * 静态变量前要加 static 关键字，而实例变量前则不加。

* 程序运行时的区别
  * 实例变量属于某个对象的属性，必须创建了实例对象，其中的实例变量才会被分配空间，才能使用这个实例变量
  * 静态变量不属于某个实例对象，而是属于类，所以也称为类变量，只要程序加载了类的字节码，不用创建任何实例对象，静态变量就会被分配空间，静态变量就可以被使用了

### 为什么不能用静态方法调用非静态方法

非静态方法是要与对象关联在一起的，必须创建一个对象后，才可以在该对象上进行方法调用，而静态方法调用时不需要创建对象，可以直接调用

当一个静态方法被调用时，可能还没有创建任何实例对象，如果从一个静态方法中发出对非静态方法的调用，那个非静态方法是关联到哪个对象上的呢，这个逻辑无法成立

## final

* 修饰的 **类无法被继承**
* 修饰的 **方法无法被重写**
* 修饰的 **局部变量，一旦赋值，不可再改变**
* 修饰的 **成员变量必须初始化值**
* 修饰的引用类型，该引用不可再重新指向其他的 Java 对象。但是 **fianl 修饰的引用，地址值不能被改变，该引用指向的对象的属性值是可以修改的**

```java
public final String str = "string";

public static void main(String[] args) {
	Test t = new Test();
    t.str = "another"; // 报错
    System.out.println(t.str+"append");// 可以运行，输出stringappend
}
```

## 构造方法

构造方法的作用，就是给对象数据进行初始化

### 特点

* 方法名与类名相同，**不能被继承，因此不能被重写，但可以被重载**

* 没有返回值类型、不能使用 return 返回值，不能被 void 修饰

* 如果一个类没有提供任何构造方法，系统 **默认提供一个无参数构造方法**。如果一个类已经手动的提供了构造方法，那么系统不会再提供任何构造方法。如果需要使用无参构造方法，就必须显式的写出
* 在创建对象的时候会 **默认执行无参构造方法，构造方法不能手动调用**

## 面向对象三大特性

### 封装

把客观事物封装成抽象的类，隐藏对象的属性和实现细节，仅对外提供公共访问方式。不用关心具体实现，提高安全性，提高了代码的复用性，减少耦合

#### 封装的使用

* 将成员变量用 private 修饰，private 仅仅是封装的一种体现形式，封装不是私有

* 提供对应的 get 和 set 方法

### 继承

**子类自动共享父类数据结构和方法的机制**，是类之间的一种关系。在定义和实现一个类的时候，可以在一个已经存在的类的基础之上来进行，把这个已经存在的类所定义的内容作为自己的内容，并加入若干新的内容。**Java 只支持单继承和多层继承**，子类可以继承父类中的 **非 private 修饰的成员方法和成员变量，构造方法不能被继承**。如果一个类没有显示的继承其他类，那么这个类会 **默认继承 Object 类**，Object 是 SUN 公司提供的 Java 中的根类

#### 优缺点

* 提高了代码的复用性
* 提高了代码的维护性
* 让类与类之间产生了关系，是多态的前提

* 增强了类之间的耦合，软件开发的一个原则是 **高内聚，低耦合**
  * 内聚：一个模块内各个元素彼此结合的紧密程度
  * 耦合：一个软件里面不同模块之间相互连接的数量

 ### 多态

**一种行为，多种状态**。同一个接口，不同的实例执行不同的操作，在面向对象语言中，接口的多种不同的实现方式即为多态。**提高了程序的扩展性，降低了代码之间的耦合**

#### 多态的实现

* 有继承
* 有方法重写
* 有父类引用指向子类对象

#### 动态绑定与静态绑定

* 动态绑定：在运行根据具体对象的类型进行绑定
* 静态绑定：在程序执行前已经被绑定

#### 类型转换

子类向父类型进行转换，是 **自动类型转换**，也叫向上转型。父类向子类型转换，是 **强制类型转换**，也叫向下转型。如果有多个子类需要强转的话，需要先使用 instanceof 判断一下对象属于哪个子类

#### 多态的使用

```java
class Father {
    public int num = 111;
    public int ff = 666;
    public void same() { System.out.println("father same"); }
    public void differentFather(){ System.out.println("father different"); }
}

class Son extends Father {
    public int num = 222;
    public int ff = 999;
    public void same() { System.out.println("son same"); }
    public void differentSon(){ System.out.println("son different"); }
}

public class Test {
    public static void main(String[] args) {
        Father f = new Son();
        f.same();// 运行的是子类的方法，输出son same
        f.differentFather();// 输出father different
        ((Son) f).differentSon();// 调用子类特有方法，需强转，输出son different
        System.out.println(f.num);// 输出父类成员变量111
        System.out.println(f.ff);// 输出父类成员变量666
        System.out.println(((Son) f).ss);// 调用子类特有成员变量，需强转，输出999
    }
}
```

## 代码块

使用 {} 括起来的代码被称为代码块

* 普通代码块：在方法中出现，限定变量生命周期，及早释放，提高内存利用率
* 同步代码块：在方法中出现，被 synchronized 修饰，语句块会自动被加上内置锁，从而实现同步

* 构造代码块：在类中方法外出现，每次调用构造方法都会执行，并且在构造方法前执行

* 静态代码块：在类中方法外出现，被 static 修饰，在类被加载的时候执行，**且只执行一次**，常用来加载驱动

### 执行顺序
```java
class Father {
    static{ System.out.println("father static"); }
    public Father(){ System.out.println("father constructor"); }
    { System.out.println("father"); }
}

class Son extends Father {
    static{ System.out.println("son static"); }
    public Son(){ System.out.println("son constructor"); }
    { System.out.println("son"); }
}

public class Test {
    public static void main(String[] args) {
        Father f = new Son();
    }
}
// 父类静态代码块->子类静态代码块->父类普通代码块->父类构造方法->子类普通代码块->子类构造方法
```

## 抽象类与接口

![20190511183035](../md.assets/20190511183035.png)

### 接口的优点

- 接口其实是一个特殊的抽象类，接口不是被类继承了，而是要被类实现
- 可以使项目分层，面向接口开发，提高开发效率
- 降低了代码之间的耦合度，提高了代码的可插拔性
- 开发中尽量使用接口，少用抽象类，一个类可以实现多个接口，却只能继承一个父类

## 内部类

内部类就是在一个类的内部声明一个类，内部类 **不能定义静态变量和方法，可以直接调用所有外部类的成员**，包括 private 修饰的变量和方法、非静态变量和方法等。接口内也可以使用内部类，但没必要





内部类的作用

1.内部类可以很好的实现隐藏

一般的非内部类，是不允许有 private 与protected权限的，但内部类可以

2．内部类拥有外围类的所有元素的访问权限

3.可是实现多重继承

4.可以避免修改接口而实现同一个类中两种同名方法的调用。





### 成员内部类

定义在一个类的内部

```java
public class Test {
    public int i1 = 1;
    private static int i2 = 2;
    public void method(){ System.out.println("Test"); }

    class InnerClass{
        public void InnerMethod(){
            System.out.println(i1);
            System.out.println(i2);
            method();
        }
    }
}
```

外部类想访问成员内部类的成员，必须 **先创建一个成员内部类的对象**。当成员内部类中拥有和外部类同名的成员变量或者方法时，**默认会调用成员内部类的成员**。如果要使用外部类的同名成员，可以通过 **`外部类名.this.成员变量/成员方法`** 调用

```java
// 其他类使用内部类，要先创建外部类的对象
public class Other{
    public static void main(String[] args){
        Test t =new Test();
        Test.InnerClass tic = t.new InnerClass();
        tic.InnerMethod();
    }
}
```

### 局部内部类

定义在一个方法或者代码块里面的类，只能访问 **方法内或者代码块内的成员**。**不能被权限修饰符或 static 修饰**

```java
public class Test {
    public static void main(String[] args) {
        class InnerClass {
            int num = 1;
        }
        int n = new InnerClass().num;
        System.out.println(n);
    }
}
```

### 匿名内部类

- 匿名类，就是没有名称的类，其名称由Java编译器给出，一般是形如：外部类名称+$+匿名类顺序，没有名称也就是其他地方就不能引用，不能实例化，只用一次，当然也就不能有构造器。
- 匿名类就是利用父类的构造函数和自身类体构造成一个类。











静态内部类

















## 数组











