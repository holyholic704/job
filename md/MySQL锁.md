**为什么要加锁**

**防止更新丢失，并不能单靠数据库事务控制器来解决，需要应用程序对要更新的数据加必要的锁来解决。**

 

**共享锁(读锁、S锁)**：对某一资源加共享锁，自身可以读该资源，其他人也可以读该资源(也可以再继续加共享锁，即共享锁可多个共存)，但无法修改。要想修改就必须等所有共享锁都释放完之后。

语法为：SELECT * FROM 表名 WHERE … LOCK IN SHARE MODE

**排他锁(写锁、X锁)**：对某一资源加排他锁，自身可以进行增删改查，其他人无法进行任何操作，数据库的**增删改操作默认都会加排他锁，而查询不会加任何锁**。

语法为：SELECT * FROM 表名 WHERE … FOR UPDATE

**更新锁(U锁)**：可以防止通常形式的死锁。如果两个事务获得了资源上的共享锁，然后试图同时更新数据，则两个事务需都要转换共享锁为排它锁，并且每个事务都等待另一个事务释放共享锁，因此发生死锁。可以使用更新锁避免这种潜在的死锁问题。**一次只有一个事务可以获得资源的更新锁。如果事务修改资源，则更新锁转换为排它锁。否则，锁转换为共享锁。**

 

**悲观锁(Pessimistic Concurrency Control，PCC)**：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。

**乐观锁(Optimistic Concurrency Control，OCC)**：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。如果发现冲突了，则让返回用户错误的信息，让用户决定如何去做。一般的实现乐观锁的方式就是记录数据版本。

 

**锁的粒度**

**表级锁**：每次操作锁住整张表。开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低；

**行级锁**：每次操作锁住一行数据。开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高；

**页面锁**：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。25个行锁可升级为一个页锁。

**数据库锁**：控制整个数据库操作

 

**死锁**：当多个事务试图以不同的顺序锁定资源时，就可能产生死锁。多个事务同时锁定同一个资源时，也会产生死锁。