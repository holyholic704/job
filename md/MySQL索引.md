## 索引

索引相当于一本字典目录，**能够提高数据库的查询效率**，表中每一个字段都可添加索引。主键会自动添加索引，在查询时，如果能通过主键查询的 **尽量使用主键查询，效率高**



### 为什么能够提高查询速度

索引的本质上是一个存储列值的数据结构。如果在某列上使用了B-树索引，那么这些列值在索引中是被排过序的，有序的值是索引能提高查询性能的主要原因。索引就是通过事先排好序，从而在查找时可以应用二分查找等高效率的算法。一般的顺序查找，复杂度为O(n)，而二分查找复杂度为O(log2n)。当n很大时，二者的效率相差及其悬殊



### 为什么能够降低增删改速度

B+树是一颗平衡树，如果我们对这颗树增删改的话，那肯定会**破坏它的原有结构**。**要维持平衡树，就必须做额外的工作**。正因为这些额外的工作**开销**，导致索引会降低增删改的速度



## 索引的优缺点

**优点**

* 加快数据的检索速度
* 通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性
* 可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义
* 在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间
* 通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能



**缺点**

* 创建索引和维护索引要耗费时间
* 索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间。如果要建立聚簇索引，那么需要的空间就会更大
* 索引降低了增删改等维护任务的速度，因为大部分数据更新需要同时更新索引



## 索引的使用场景

**什么时候创建索引**

* 经常需要查询的表
* 数据特别多，数据分布范围广的表
* 经常使用 WHERE 子句中的列，加快条件的判断速度
* 在作为主键的列上，强制该列的唯一性和组织表中数据的排列结构
* 经常用于连接的列，这些列主要是一些外键，可以加快连接的速度
* 经常需要根据范围进行搜索的列，因为索引已经排序，其指定的范围是连续的
* 经常需要排序的列，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间



**什么时候不要创建索引**

* 经常需要增删改的表
* 很少需要查询的表
* 数据特别少的表
* 列名不经常作为连接条件或出现在 WHERE 子句中

* 含有 text、image、bit 数据类型的列，这些列的数据量要么相当大，要么取值很少
* 当修改性能远远大于检索性能时，不应该创建索引。这是因为，修改性能和检索性能是互相矛盾的。当增加索引时，会提高检索性能，但是会降低修改性能。当减少索引时，会提高修改性能，降低检索性能



- 对于非常小的表、大部分情况下简单的全表扫描比建立索引更高效
- 对于中到大型的表，索引就非常有效
- 但是对于特大型的表，建立和维护索引的代价将会随之增长。这种情况下，需要用到一种技术可以直接区分出需要查询的一组数据，而不是一条记录一条记录地匹配，例如可以使用分区技术



## 索引的种类

* 单列索引：一个索引只包含单个列，但一个表中可以有多个单列索引
  * 普通索引：MySQL中基本索引类型，没有什么限制，允许在定义索引的列中插入重复值和空值，纯粹为了查询数据更快一点
  * 唯一索引：索引列中的值必须是唯一的，但是允许为空值
  * 主键索引：为表定义一个主键将自动创建主键索引，是一种特殊的唯一索引，不允许有空值
* 组合索引：在表中的多个字段组合上创建的索引，只有在查询条件中使用了这些字段的左边字段时，索引才会被使用，使用 **组合索引时遵循最左前缀集合**，即最左优先
* 全文索引：只有在MyISAM引擎上才能使用，**只能在CHAR，VARCHAR，TEXT类型字段上使用**全文索引，在一堆文字中，通过其中的某个关键字等，就能找到该字段所属的记录行
* 空间索引：空间索引是对空间数据类型的字段建立的索引，MySQL中的空间数据类型有四种：GEOMETRY、POINT、LINESTRING、POLYGON



**最左匹配原则**：

- 索引可以简单如一个列`(a)`，也可以复杂如多个列`(a, b, c, d)`，即**联合索引**。
- 如果是联合索引，那么key也由多个列组成，同时，索引只能用于查找key是否**存在（相等）**，遇到范围查询`(>、<、between、like`左匹配)等就**不能进一步匹配**了，后续退化为线性查找。
- 因此，**列的排列顺序决定了可命中索引的列数**。



## 聚集和非聚集索引

聚集索引：表中各行的物理顺序与键值的逻辑（索引）顺序相同，每个表只能有一个

非聚集索引：也叫做二级索引，非聚集索引指定表的逻辑顺序。数据存储在一个位置，索引存储在另一个位置，索引中包含指向数据存储位置的指针。可以有多个，小于249个



简单概括：

- 聚集索引就是以**主键**创建的索引
- 非聚集索引就是以**非主键**创建的索引

区别：

- 聚集索引在叶子节点存储的是**表中的数据**
- 非聚集索引在叶子节点存储的是**主键和索引列**
- 使用非聚集索引查询出数据时，**拿到叶子上的主键再去查到想要查找的数据**。(拿到主键再查找这个过程叫做**回表**)



非聚集索引在建立的时候也**未必是单列**的，可以多个列来创建索引。

- 此时就涉及到了哪个列会走索引，哪个列不走索引的问题了(最左匹配原则-->后面有说)
- **创建多个单列(非聚集)索引的时候，会生成多个索引树**(所以过多创建索引会占用磁盘空间)





覆盖索引

- 我们前面知道了，如果不是聚集索引，叶子节点存储的是主键+列值
- 最终还是要“回表”，也就是要通过主键**再**查找一次。这样就会比较慢
- 覆盖索引就是把要**查询出的列和索引是对应的**，不做回表操作

比如说：

- 现在我创建了索引`(username,age)`，在查询数据的时候：`select username , age from user where username = 'Java3y' and age = 20`。
- 很明显地知道，我们上边的查询是走索引的，并且，**要查询出的列在叶子节点都存在**！所以，就不用回表了~
- 所以，能使用覆盖索引就尽量使用吧~



## 索引的类型

索引是在存储引擎层实现的，不是在服务器层实现的，所以不同存储引擎具有不同的索引类型和实现，索引能够轻易将查询性能提升几个数量级



### B+Tree 索引

MySQL 存储引擎的 **默认** 索引类型。查找速度很快，因为不需要进行全表扫描，只需要对树进行搜索。

除了用于查找，还可以用于排序和分组。

可以指定多个列作为索引列，多个索引列共同组成键。适用于全键值、键值范围和键前缀查找，其中键前缀查找只适用于最左前缀查找。如果不是按照索引列的顺序进行查找，则无法使用索引。

InnoDB 的 B+Tree 索引分为主索引和辅助索引。主索引的叶子节点 data 域记录着完整的数据记录，这种索引方式被称为聚簇索引。因为无法把数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引

辅助索引的叶子节点的 data 域记录着主键的值，因此在使用辅助索引进行查找时，需要先查找到主键值，然后再到主索引中进行查找



### 哈希索引

哈希索引就是采用一定的哈希算法，把键值换算成新的哈希值，检索时不需要类似 B+ 树那样从根节点到叶子节点逐级查找，效率极高。在 MySQL 中只有 Memory 引擎显式支持哈希索引。

InnoDB 存储引擎有一个特殊的功能叫“自适应哈希索引”，当某个索引值被使用的非常频繁时，会在 B+Tree 索引之上再创建一个哈希索引，这样就让 B+Tree 索引具有哈希索引的一些优点，比如快速的哈希查找

在绝大多数需求为单条记录查询的时候，可以选择哈希索引，查询性能最快；其余大部分场景，建议选择BTree索引



#### 缺点

* 无法用于排序与分组

- 只支持精确查找，无法用于部分查找和范围查找
- 不支持最左匹配原则
- 不支持范围查询
- 如果哈希冲突很多，查找速度会变得很慢
- 哈希索引只包含哈希值和行指针，而不存储字段值，所以不能使用索引中的值来避免读取行。不过，访问内存中的行的速度很快，所以大部分情况下这一点对性能影响并不明显；



### 空间数据索引（R-Tree）

相对于 BTREE，RTREE 的优势在于范围查找。MyISAM 存储引擎支持空间数据索引，可以用于地理数据存储。

空间数据索引会从所有维度来索引数据，可以有效地使用任意维度来进行组合查询。

RTREE在MySQL很少使用，仅支持geometry数据类型

必须使用 GIS 相关的函数来维护数据。



### 全文索引

全文索引使用倒排索引实现，它记录着关键词到其所在文档的映射。MyISAM 存储引擎支持全文索引，用于查找文本中的关键词，而不是直接比较索引中的值。查找条件使用 MATCH AGAINST，而不是普通的 WHERE。它的出现是为了解决针对文本的模糊查询效率较低的问题。

**InnoDB 存储引擎在 MySQL 5.6.4 版本中开始支持全文索引**

可以在CREATE TABLE ，ALTER TABLE ，CREATE INDEX 使用，不过目前只有 CHAR、VARCHAR ，TEXT 列上可以创建全文索引





**MyISAM:** B+Tree叶节点的data域存放的是数据记录的地址。在索引检索的时候，首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其 data 域的值，然后以 data 域的值为地址读取相应的数据记录。这被称为“非聚簇索引”。

**InnoDB:** 其数据文件本身就是索引文件。相比MyISAM，索引文件和数据文件是分离的，其表数据文件本身就是按B+Tree组织的一个索引结构，树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。这被称为“聚簇索引（或聚集索引）”。而其余的索引都作为辅助索引，辅助索引的data域存储相应记录主键的值而不是地址，这也是和MyISAM不同的地方。**在根据主索引搜索时，直接找到key所在的节点即可取出数据；在根据辅助索引查找时，则需要先取出主键的值，再走一遍主索引。** **因此，在设计表的时候，不建议使用过长的字段作为主键，也不建议使用非单调的字段作为主键，这样会造成主索引频繁分裂**



## 操作索引语句

```mysql
# 创建表时创建
CREATE TABLE `test` (
    `id` INT (11) NOT NULL AUTO_INCREMENT,
	...
    PRIMARY KEY (`id`)
    INDEX [索引名] (字段名(长度))
) ENGINE = INNODB DEFAULT CHARSET = utf8;

# 增加索引
alter table [表名] add [index | unique | primary key | fulltext | spatial] [索引名] (字段名);

# 创建索引
create index [索引名] on [表名] (字段名);
create unique index [索引名] on [表名] (字段名);

# 删除索引
drop index [索引名] on [表名];
alter table [表名] drop index [索引名];

# 显示索引信息，可以通过添加\G来格式化输出信息。
show index from [表名];
```



## 索引优化

### 独立的列

在进行查询时，索引列不能是表达式的一部分，也不能是函数的参数，否则无法使用索引。



### 多列索引

在需要使用多个列作为条件进行查询时，使用多列索引比使用多个单列索引性能更好



### 索引列的顺序

让选择性最强的索引列放在前面。索引的选择性是指：不重复的索引值和记录总数的比值 `COUNT(DISTINCT col) / COUNT(*)`。最大值为 1，此时每个记录都有唯一的索引与其对应。选择性越高，查询效率也越高



### 前缀索引

对于 BLOB、TEXT 和 VARCHAR 类型的列，必须使用前缀索引，只索引开始的部分字符。对于前缀长度的选取需要根据索引选择性来确定



### 覆盖索引

索引包含所有需要查询的字段的值

**优点**

- 索引通常远小于数据行的大小，只读取索引能大大减少数据访问量
- 如 MyISAM 等存储引擎在内存中只缓存索引，而数据依赖于操作系统来缓存。因此，只访问索引可以不使用系统调用，缩短时间
- 对于 InnoDB 引擎，若辅助索引能够覆盖查询，则无需访问主索引



### 聚簇索引

聚簇索引并不是一种索引类型，而是一种数据存储方式。聚簇表示数据行和相邻的键值紧密地存储在一起，InnoDB 的聚簇索引在同一个结构中保存了 B+Tree 索引和数据行。因为无法把数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引

**优点**

* 可以把相关数据保存在一起，减少 I/O 操作
* 数据访问更快

**缺点**

* 聚簇索引最大限度提高了 I/O 密集型应用的性能，但是如果数据全部放在内存，就没必要用聚簇索引
* 插入速度严重依赖于插入顺序，按主键的顺序插入是最快的
* 更新操作代价很高，因为每个被更新的行都会移动到新的位置
* 当插入到某个已满的页中，存储引擎会将该页分裂成两个页面来容纳该行，页分裂会导致表占用更多的磁盘空间
* 如果行比较稀疏，或者由于页分裂导致数据存储不连续时，聚簇索引可能导致全表扫描速度变慢



## 更多

- [InnoDB数据页结构](https://mp.weixin.qq.com/s?__biz=MzIxNTQ3NDMzMw==&mid=2247483678&idx=1&sn=913780d42e7a81fd3f9b747da4fba8ec&chksm=979688eca0e101fa0913c3d2e6107dfa3a6c151a075c8d68ab3f44c7c364d9510f9e1179d94d&scene=21#wechat_redirect)
- [MySQL的索引](https://mp.weixin.qq.com/s?__biz=MzIxNTQ3NDMzMw==&mid=2247483701&idx=1&sn=bd229dd584f51ef4fe545d44ad8cdbf9&chksm=979688c7a0e101d1b5c752094013b78f5bd50ab905257ba82149d85d35ea07aba1a15b0e52b4&mpshare=1&scene=1&srcid=0409Tn66UYWSWvqEVlOpwGtR&key=6cd553e86912686a47d76f2d900b1b5b388c90b29708f016db3a6e1bcebe032220ba63626095c4298f32cda7d0d7bd11bded2365f05c32e522584dd149b98db0bb8549ef144cdca694665d31d35cfeef&ascene)
- [MySQL索引背后的数据结构及算法原理](http://blog.codinglabs.org/articles/theory-of-mysql-index.html)
- [索引的使用、原理和设计优化](https://blog.csdn.net/Jack__Frost/article/details/72571540)
- [聚集索引与非聚集索引的总结](https://www.cnblogs.com/s-b-b/p/8334593.html)