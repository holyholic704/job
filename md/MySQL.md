## 数据类型

- 整型

  - tinyint、smallint、mediumint、int、bigint

- 浮点型

  - float、double
  - 可以指定列宽，如 double(5,2) 表示最多有 5 位，其中必须有 2 位小数

- 字符串

  - char：固定长度，如 char(10)，如果不足 10 位则会自动补足 10 位
  - varchar：可变长度，如 varchar(10)，如果不足10位不会补足，**性能不如 char 高**
  - text：适用于大文本内容

- 日期与时间

  - date：日期，格式为 `yyyy-MM-dd`

  - time：时间，格式为 `hh:mm:ss`
  - timestamp：时间戳，格式为 `yyyy-MM-dd hh:mm:ss`，**会自动赋值**
  - datetime：日期时间，格式为 `yyyy-MM-dd hh:mm:ss`



## 存储过程

存储过程就是作为可执行对象存放在数据库中的一个或多个SQL命令
通俗来讲：存储过程其实就是能完成一定操作的一组SQL语句



优点

- 可以将代码封装，并保存在数据库中
- 存储过程可以回传值，并可以接受参数
- 存储过程无法使用 select 指令来运行，因为它是子程序，与查看表，数据表或用户定义函数不同
- 存储过程可以用在数据检验，强制实行商业逻辑等



缺点

- 存储过程，往往定制化于特定的数据库上，因为支持的编程语言不同。当切换到其他厂商的数据库系统时，需要重写原有的存储过程
- 存储过程的性能调校与撰写，受限于各种数据库系统



存储过程的优点：

- **能够将代码封装起来**
- **保存在数据库之中**
- **让编程语言进行调用**
- **存储过程是一个预编译的代码块，执行效率比较高**
- **一个存储过程替代大量T_SQL语句 ，可以降低网络通信量，提高通信速率**

存储过程的缺点：

- **每个数据库的存储过程语法几乎都不一样，十分难以维护（不通用）**
- **业务逻辑放在数据库上，难以迭代**



## drop，delete，truncate的区别

|             delete             |       drop       |       truncate       |
| :----------------------------: | :--------------: | :------------------: |
|            属于 DML            |     属于 DDL     |       属于 DDL       |
|          不会自动提交          | 执行后会自动提交 |   执行后会自动提交   |
|    事物提交后才生效，可回滚    |     不能回滚     |       不能回滚       |
|      会触发相应的 trigger      | 不会触发 trigger |   不会触发 trigger   |
|           可带where            |   不可带where    |     不可带where      |
| 表结构在，删除部分或全部表内容 | 表结构和内容删除 |      表内容删除      |
|         三者中速度最慢         |  三者中速度最快  | 三者中速度最速度中等 |

**如果是整理表内部的碎片，可以用 truncate 跟上 reuse stroage，再重新导入或插入数据**



## 存储引擎

采用不同的技术将数据存储在文件或内存中，不同的技术有不同的存储机制。**存储引擎是 MySQL 特有的**，在不同的业务场景下选择不同的存储引擎，这样能够发挥 MySQL 的最佳性能

 

### 常用的存储引擎

* MyISAM：节省数据库空间，适用于数据读远大于修改
* InnoDB：支持事务，适用于如果数据修改较多时
* MEMORY：存储在内存中，速度快

 

### MyISAM 与 InnoDB 的区别

|          |             MyISAM             |       InnoDB       |
| :------: | :----------------------------: | :----------------: |
|   事务   |             不支持             |        支持        |
|   外键   |             不支持             |        支持        |
|   行锁   |       不支持，只支持表锁       |        支持        |
| 全文索引 |              支持              |       不支持       |
|  热备份  |             不支持             |        支持        |
| count()  | 直接返回值，因为保存了表的行数 | 先遍历表，再返回值 |



## 视图

什么是视图？以及视图的使用场景有哪些？

有的时候，我们可能只关系一张数据表中的某些字段，而另外的一些人只关系同一张数据表的某些字段...

那么把全部的字段都都显示给他们看，这是不合理的。

我们应该做到：**他们想看到什么样的数据，我们就给他们什么样的数据...一方面就能够让他们只关注自己的数据，另一方面，我们也保证数据表一些保密的数据不会泄露出来...**

视图其实就是一个查询结果，视图的作用可以隐藏表的实现细节。

 我们在查询数据的时候，常常需要编写非常长的SQL语句，几乎每次都要写很长很长....上面已经说了，**视图就是基于查询的一种虚表，也就是说，视图可以将查询出来的数据进行封装。。。那么我们在使用的时候就会变得非常方便**...

值得注意的是：**使用视图可以让我们专注与逻辑，但不提高查询效率**

视图是一种基于数据表的一种**虚表**

- （2）视图建立在已有表的基础上, 视图赖以建立的这些表称为基表
- （3）**向视图提供数据内容的语句为 SELECT 语句,可以将视图理解为存储起来的 SELECT 语句**
- （4）视图向用户提供基表数据的另一种表现形式
- （5）视图没有存储真正的数据，真正的数据还是存储在基表中
- （6）程序员虽然操作的是视图，但最终视图还会转成操作基表
- （7）一个基表可以有0个或多个视图



```mysql
# 创建视图
create view [视图名称] as [查询语句]；

# 修改视图
alter view [视图名称] as [查询语句]；

# 删除视图
drop view if exists [视图名称]；
```



## 字符集与字符序

### 字符集（character set）

定义了字符以及字符的编码。在数据的存储上，MySQL 提供了不同的字符集支持，默认的字符集为 latin1



### 字符序（collation）

定义了字符的比较规则。每种字符集都可能有多种校对规则，并且都有一个默认的校对规则，并且每个校对规则只是针对某个字符集，和其他的字符集么有关系。每个字符集都有默认的字符序，一个字符集对应至少一种字符序，两个不同的字符集不能有相同的字符序



```mysql
# 查看所有字符集
show character set;

# 查看指定字符集
show character set where charset = 'utf8';

# 查看当前使用的字符集
show variables like 'character%';

# character_set_client：客户端请求数据的字符集
# character_set_connection：客户机/服务器连接的字符集
# character_set_database：默认数据库的字符集，无论默认数据库如何改变，都是这个字符集；如果没有默认数   据库，那就使用 character_set_server指定的字符集，这个变量建议由系统自己管理，不要人为定义
# character_set_filesystem：把os上文件名转化成此字符集，即把character_set_client转换           character_set_filesystem， 默认binary是不做任何转换的
# character_set_results：结果集，返回给客户端的字符集
# character_set_server：数据库服务器的默认字符集
# character_set_system：系统字符集，这个值总是utf8，不需要设置

# 查看所有字符序
show collation;

# 查看当前使用的字符序
show variables like 'collation%';

# collation_connection：当前连接的字符集
# collation_database：当前日期的默认校对。每次用USE语句来“跳转”到另一个数据库的时候，这个变量的值就   会改变。如果没有当前数据库，这个变量的值就是collation_server变量的值
# collation_server：服务器的默认校对
```



## 事务

### 什么是事务（Transaction）

可以 **保证多个操作的原子性**，对于数据库来说，事务可以保证一系列操作要么全成功，要么全失败，通常一个事务对应一个完整的业务



### 事务的四个特征 ACID

* 原子性（Atomicity）
  * 事务开始后所有操作，要么全部做完，要么全部不做，不可能停滞在中间环节。事务执行过程中出错，会回滚到事务开始前的状态
* 一致性（Consistency）
  * 事务的开始和结束，数据都必须保持一致状态

* 隔离性（Isolation）
  * 同一时间，只允许一个事务请求同一数据，不同的事务互不影响

* 持久性（Durability）
  * 事务完成之后，事务对数据库所作的更改将持久地保存在数据库中，不会被回滚

 

### 事务的隔离级别

* 读未提交（Read uncommitted）
  * 事务隔离的最低级别，任何情况都无法保证
  * 事务中的修改，即使没有提交，其他事务也可以看得到，这里读取到的数据叫做“脏数据”，一般只是理论上存在，数据库的默认隔离级别都高于该级别

* 读已提交（Read committed）
  * 可避免脏读
  * 事务中的修改提交后，其他事务才可以看得到

* 重复读（Repeatable read）
  * 可避免脏读、不可重复读
  * 保证了一个事务不会修改已经由另一个事务读取但未提交的数据，MySQL 默认的隔离级别

* 串行化（Serializable）
  * 可避免脏读、不可重复读、幻读
  * 保证在同一个时间点上只有一个事务操作数据库，该级别可以解决“幻读”的问题。但是这种级别一般很少使用，因为吞吐量太低，用户体验不好



### 并发事务带来的问题

* 脏读：一个事务读取到另外一个事务未提交的数据

* 不可重复读：一个事务读取到另一个事务已提交的数据，导致多次读取同一数据时，结果不一致。前后多次读取，数据内容不一致

* 幻读：一个事务内读取到另一个事务插入的数据，导致前后读取不一致。前后多次读取，数据总量不一致

* 更新丢失：当多个事务更新同一数据时，由于不知道其他事务的存在，就会发生丢失更新问题，最后的更新覆盖了其他事务所做的更新

 

#### 不可重复读和幻读的区别

* 不可重复读是读取了其他事务更改的数据，针对 update、delete 操作
  * 解决：使用行级锁，锁定该行，事务多次读取操作完成后释放锁，之后才允许其他事务更改刚才的数据

* 幻读是读取了其他事务新增的数据，针对 insert 操作
  * 解决：使用表级锁，锁定整张表，事务多次读取数据总量之后释放锁，之后才允许其他事务新增数据

 

* *更多：[对于脏读，不可重复读，幻读的一点理解](https://blog.csdn.net/yuxin6866/article/details/52649048)、[数据库并发事务存在的问题](https://blog.csdn.net/starlh35/article/details/76445267)*



### 事务控制语句

```mysql
# 开启事务
start transaction;
# 或者
begin;

# 提交
commit;
# 或者
commit work;

# 回滚
# 结束用户的事务，并撤销正在进行的所有未提交的修改
rollback;
# 或者
rollback work;

# 创建保存点
savepoint [保存点];

# 删除保存点
release savepoint [保存点];

# 回滚到保存点
rollback savepoint [保存点];

# 查看当前会话的隔离级别
select @@tx_isolation；

# 自动提交
# 0表示禁止，1表示开启
set autocommit = 0|1

# 设置事务隔离级别
# global全局，session本次会话
set [global | session] transaction isolation level [read uncommitted | read committed | repeatable read | serializable];
```



## 触发器（trigger）

监视某种情况，并触发某种操作，它是一种保证数据完整性的方法，它是与表事件相关的特殊的存储过程，它的执行而是由事件来触发，当对一个表进行增删改操作时就会激活执行



### 不建议使用

非常消耗资源，如果使用的话，确定它是非常高效的，增删改非常频繁的表上不要使用触发器，不需要的触发器应及时删除。触发器的功能基本都可以用存储过程来实现



### 创建触发器

```mysql
# trigger_time，指定了触发执行的时间，在事件之前或是之后，参数：before、after
# 触发事件，满足相应条件时触发，参数：insert、update、delete
# for each row，所有记录的操作满足条件都会触发该触发器，即触发器的触发频率是针对每一行数据触发一次
# 触发顺序（MySQL5.7+），定义多个触发器时，选择触发器执行的先后顺序，参数：follows、precedes
create trigger [触发器名]
[触发时间] [触发事件]
on [表名] for each row [触发顺序]
[执行语句];

# 多个执行语句的触发器
create trigger [触发器名]
[触发时间] [触发事件]
on [表名] for each row [触发顺序]
begin
	[执行语句]
end;

# 查看触发器
show triggers;

# 
drop trigger;
```



### new 与 old

对同一个表相同触发时间的相同触发事件，只能定义一个触发器，可以使用 new 和 old 来引用触发器中发生变化的记录内容

* insert 型触发器
  * new 用来表示将要或已经插入的新数据
* update 型触发器
  * new 用来表示将要或已经被修改的新数据，old 用来表示将要或已经被修改的原数据
* delete 型触发器
  * old 用来表示将要或已经被删除的原数据



* *更多：[MySQL触发器trigger的使用](https://www.cnblogs.com/geaozhang/p/6819648.html)*



## 权限管理

### MySQL 的权限是如何实现的

服务器首先会检查你是否允许连接，因为创建用户的时候会加上主机限制，可以限制成本地、某个IP、某个IP段、以及任何地方等，只允许你从配置的指定地方登陆。然后，如果你能连接，MySQL 会检查你发出的每个请求，看你是否有足够的权限实施它



### MySQL 的权限



![20190429144530](../md.assets/20190429144530.png)



### 如何使用

* 只授予能满足需要的最小权限，防止用户干坏事
* 创建用户的时候限制用户的登录主机，一般是限制成指定 IP 或者内网 IP 段

* 初始化数据库的时候删除没有密码的用户。安装完数据库的时候会自动创建一些用户，这些用户默认没有密码

* 为每个用户设置满足密码复杂度的密码

* 定期清理不需要的用户，回收权限或者删除用户

```mysql
# 创建一个只允许从本地登录的超级用户jack，并允许将权限赋予别的用户
grant all privileges on *.* to jack@'localhost' identified by "jack" with grant option;

# all privileges：表示所有权限，也可以使用select、update等权限
# on：指定权限针对哪些库和表
# *.*：中前面的*号用来指定数据库名，后面的*号用来指定表名
# to：将权限赋予某个用户
# jack@'localhost'：表示jack用户，@后面接限制的主机，可以是IP、IP段、域名以及%，%表示任何地方
# identified by:指定用户的登录密码
# with grant option：表示该用户可以将自己拥有的权限授权给别人
# 可以使用grant重复给用户添加权限，权限叠加

# 刷新权限，使权限生效
flush privileges;

# 查看当前用户的权限
show grants;

# 查看某个用户的权限
show grants for 'jack'@'%';

# 回收权限
revoke delete on *.* from 'jack'@'localhost';

# 删除用户
select host,user,password from user;
drop user 'jack'@'localhost';

# 重命名用户
rename user 'jack'@'%' to 'jim'@'%';
```

*更多：[MySQL之权限管理](https://www.cnblogs.com/Richardzhu/p/3318595.html)*