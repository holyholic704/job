## 数据类型

- 整型

  - tinyint、smallint、mediumint、int、bigint

- 浮点型

  - float、double
  - 可以指定列宽，如 double(5,2) 表示最多有 5 位，其中必须有 2 位小数

- 字符串

  - char：固定长度，如 char(10)，如果不足 10 位则会自动补足 10 位
  - varchar：可变长度，如 varchar(10)，如果不足10位不会补足，**性能不如 char 高**
  - text：适用于大文本内容

- 日期与时间

  - date：日期，格式为 `yyyy-MM-dd`

  - time：时间，格式为 `hh:mm:ss`
  - timestamp：时间戳，格式为 `yyyy-MM-dd hh:mm:ss`，**会自动赋值**
  - datetime：日期时间，格式为 `yyyy-MM-dd hh:mm:ss`



## 存储过程

存储过程就是作为可执行对象存放在数据库中的一个或多个SQL命令
通俗来讲：存储过程其实就是能完成一定操作的一组SQL语句



优点

- 可以将代码封装，并保存在数据库中
- 存储过程可以回传值，并可以接受参数
- 存储过程无法使用 select 指令来运行，因为它是子程序，与查看表，数据表或用户定义函数不同
- 存储过程可以用在数据检验，强制实行商业逻辑等



缺点

- 存储过程，往往定制化于特定的数据库上，因为支持的编程语言不同。当切换到其他厂商的数据库系统时，需要重写原有的存储过程
- 存储过程的性能调校与撰写，受限于各种数据库系统



存储过程的优点：

- **能够将代码封装起来**
- **保存在数据库之中**
- **让编程语言进行调用**
- **存储过程是一个预编译的代码块，执行效率比较高**
- **一个存储过程替代大量T_SQL语句 ，可以降低网络通信量，提高通信速率**

存储过程的缺点：

- **每个数据库的存储过程语法几乎都不一样，十分难以维护（不通用）**
- **业务逻辑放在数据库上，难以迭代**





drop，delete，truncate的区别

三者都是删除的意思

速度drop > truncate > delete

delete(删除部分)和truncate(删除所有)只删除表的数据不删除表的结构，drop删除表。

想删除部分数据时，delete删除时要带上where语句，删除后的数据可以恢复。

delete是DML语句，不会自动提交。drop和truncate都是DDL语句，执行后会自动提交。

保留表而将所有数据删除，如果和事务无关，用truncate 。

如果和事务有关，或者想触发trigger，用delete。

如果是整理表内部的碎片，可以用truncate跟上reuse stroage，再重新导入或插入数据



我们来对比一下他们的区别：

drop table

- 1)属于DDL
- 2)不可回滚
- 3)不可带where
- 4)表内容和结构删除
- 5)删除速度快

truncate table

- 1)属于DDL
- 2)不可回滚
- 3)不可带where
- 4)表内容删除
- 5)删除速度快

delete from

- 1)属于DML
- 2)可回滚
- 3)可带where
- 4)表结构在，表内容要看where执行的情况
- 5)删除速度慢,需要逐行删除
- **不再需要一张表的时候，用drop**
- **想删除部分数据行时候，用delete，并且带上where子句**
- **保留表而删除所有数据的时候用truncate**

 

## 存储引擎

采用不同的技术将数据存储在文件或内存中，不同的技术有不同的存储机制。**存储引擎是 MySQL 特有的**，在不同的业务场景下选择不同的存储引擎，这样能够发挥 MySQL 的最佳性能

 

### 常用的存储引擎

* MyISAM：节省数据库空间，适用于数据读远大于修改
* InnoDB：支持事务，适用于如果数据修改较多时
* MEMORY：存储在内存中，速度快

 

### MyISAM 与 InnoDB 的区别

|          |             MyISAM             |       InnoDB       |
| :------: | :----------------------------: | :----------------: |
|   事务   |             不支持             |        支持        |
|   外键   |             不支持             |        支持        |
|   行锁   |       不支持，只支持表锁       |        支持        |
| 全文索引 |              支持              |       不支持       |
|  热备份  |             不支持             |        支持        |
| count()  | 直接返回值，因为保存了表的行数 | 先遍历表，再返回值 |



## 视图

> 什么是视图？以及视图的使用场景有哪些？

视图是一种基于数据表的一种**虚表**

- （1）视图是一种虚表
- （2）视图建立在已有表的基础上, 视图赖以建立的这些表称为基表
- （3）**向视图提供数据内容的语句为 SELECT 语句,可以将视图理解为存储起来的 SELECT 语句**
- （4）视图向用户提供基表数据的另一种表现形式
- （5）视图没有存储真正的数据，真正的数据还是存储在基表中
- （6）程序员虽然操作的是视图，但最终视图还会转成操作基表
- （7）一个基表可以有0个或多个视图

有的时候，我们可能只关系一张数据表中的某些字段，而另外的一些人只关系同一张数据表的某些字段...

那么把全部的字段都都显示给他们看，这是不合理的。

我们应该做到：**他们想看到什么样的数据，我们就给他们什么样的数据...一方面就能够让他们只关注自己的数据，另一方面，我们也保证数据表一些保密的数据不会泄露出来...**

视图其实就是一个查询结果，视图的作用可以隐藏表的实现细节。

 我们在查询数据的时候，常常需要编写非常长的SQL语句，几乎每次都要写很长很长....上面已经说了，**视图就是基于查询的一种虚表，也就是说，视图可以将查询出来的数据进行封装。。。那么我们在使用的时候就会变得非常方便**...

值得注意的是：**使用视图可以让我们专注与逻辑，但不提高查询效率**

**创建视图**：create view 视图名称 as 查询语句；

**修改视图**：alter view 视图名称 as 查询语句；

**删除视图**：drop view if exists 视图名称；

 

## 事务

### 什么是事务（Transaction）

可以**保证多个操作的原子性**，对于数据库来说，事务可以保证一系列操作要么全成功，要么全失败，通常一个事务对应一个完整的业务。



### 事务的四个特征 ACID

* 原子性（Atomicity）
  * 事务开始后所有操作，要么全部做完，要么全部不做，不可能停滞在中间环节。事务执行过程中出错，会回滚到事务开始前的状态
* 一致性（Consistency）
  * 事务的开始和结束，数据都必须保持一致状态

* 隔离性（Isolation）
  * 同一时间，只允许一个事务请求同一数据，不同的事务互不影响

* 持久性（Durability）
  * 事务完成之后，事务对数据库所作的更改将持久地保存在数据库中，不会被回滚

 

### 事务的隔离级别

* 读未提交（Read uncommitted）
  * 事务隔离的最低级别，任何情况都无法保证
  * 事务中的修改，即使没有提交，其他事务也可以看得到，这里读取到的数据叫做“脏数据”，一般只是理论上存在，数据库的默认隔离级别都高于该级别

* 读已提交（Read committed）
  * 可避免脏读
  * 事务中的修改提交后，其他事务才可以看得到

* 重复读（Repeatable read）
  * 可避免脏读、不可重复读
  * 保证了一个事务不会修改已经由另一个事务读取但未提交的数据，MySQL 默认的隔离级别

* 串行化（Serializable）
  * 可避免脏读、不可重复读、幻读
  * 保证在同一个时间点上只有一个事务操作数据库，该级别可以解决“幻读”的问题。但是这种级别一般很少使用，因为吞吐量太低，用户体验不好



#### 脏读、幻读、不可重复读

* 脏读：一个事务读取到另外一个事务未提交的数据

* 不可重复读：一个事务读取到另一个事务已提交的数据，导致多次读取同一数据时，结果不一致。前后多次读取，数据内容不一致

* 幻读：一个事务内读取到另一个事务插入的数据，导致前后读取不一致。前后多次读取，数据总量不一致

* 更新丢失：当多个事务选择同一行进行更新时，由于不知道其他事务的存在，就会发生丢失更新问题，最后的更新覆盖了其他事务所做的更新

 

##### 不可重复读和幻读的区别

* 不可重复读是读取了其他事务更改的数据，针对 update、delete 操作
  * 解决：使用行级锁，锁定该行，事务多次读取操作完成后释放锁，这个时候才允许其他事务更改刚才的数据

* 幻读是读取了其他事务新增的数据，针对 insert 操作
  * 解决：使用表级锁，锁定整张表，事务多次读取数据总量之后释放锁，这个时候才允许其他事务新增数据

 

### 事务控制语句

```mysql
# 开启事务
start transaction;
# 或者
begin;

# 提交
commit;
# 或者
commit work;

# 回滚
# 结束用户的事务，并撤销正在进行的所有未提交的修改
rollback;
# 或者
rollback work;

# 创建保存点
savepoint [保存点];

# 删除保存点
release savepoint [保存点];

# 回滚到保存点
rollback savepoint [保存点];

# 查看当前会话的隔离级别
select @@tx_isolation；

# 自动提交
# 0表示禁止，1表示开启
set autocommit = 0|1

# 设置事务隔离级别
# global全局，session本次会话
set [global | session] transaction isolation level [read uncommitted | read committed | repeatable read | serializable];
```



## OTHER

MyIASM 和 Innodb 两种引擎所使用的索引的数据结构是什么？

答案:都是B+树

MyIASM引擎，B+树的数据结构中存储的内容实际上是实际数据的地址值。也就是说它的索引和实际数据是分开的，**只不过使用索引指向了实际数据。这种索引的模式被称为非聚集索引。**

Innodb引擎的索引的数据结构也是B+树，**只不过数据结构中存储的都是实际的数据，这种索引有被称为聚集索引**