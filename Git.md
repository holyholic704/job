

## 什么是Git

Git是目前世界上最先进的分布式版本控制系统



## Git与SVN的区别

* **SVN是集中式版本控制系统，版本库是集中放在中央服务器的**，而干活的时候首先要从中央服务器哪里得到最新的版本，然后干活，干完后，需要把自己做完的活推送到中央服务器。集中式版本控制系统是**必须联网**才能工作

* **Git是分布式版本控制系统，没有中央服务器，每个人的电脑就是一个完整的版本库**，这样，工作的时候就不需要联网了，因为版本都是在自己的电脑上。既然每个人的电脑都有一个完整的版本库，那多个人如何协作呢？比如说自己在电脑上改了文件A，其他人也在电脑上改了文件A，这时，你们两之间只需把各自的修改推送给对方，就可以互相看到对方的修改了

* **Git 只关心文件数据的整体是否发生变化，而SVN这类版本控制系统则只关心文件内容的具体差异**。这类系统每次记录有哪些文件作了更新，以及都更新了哪些行的什么内容，然而Git并不保存这些前后变化的差异数据。实际上，Git更像是把变化的文件作快照后，记录在一个微型的文件系统中。每次提交更新时，它会纵览一遍所有文件的指纹信息并对文件作一快照，然后保存一个指向这次快照的索引。为提高性能，若文件没有变化，Git 不会再次保存，而只对上次保存的快照作一链接
* **在Git 中的绝大多数操作都只需要访问本地文件和资源，不必联网就可以看到所有的历史版本记录，而SVN 却需要联网**。因为 Git 在本地磁盘上就保存着所有当前项目的历史更新，所以处理起来速度飞快，但我们需要浏览项目的历史更新摘要，Git 不用跑到外面的服务器上去取数据回来，而直接从本地数据库读取后展示给你看。如果想要看当前版本的文件和一个月前的版本之间有何差异，**Git 会取出一个月前的快照和当前文件作一次差异运算**
* **SVN 断开网络就无法commit代码，但是Git 可以先commit到本地仓库**。用SVN的话，没有网络时，无法commit代码，因为SVN 每次commit都必须联网，而且有网络的情况下每一次commit都会花上数秒甚至更长时间。但用 Git 的话，因为是在本地仓库commit所以几乎不需要时间，而且commit一定要频繁，不然无法记录你的改动，如果你一天commit一次，中间的修改你就找不回来，然后等到了有网络的时候再将版本纪录和代码一起上传到远程仓库
* **Git 的内容完整性要优于SVN**。因为Git 在 commit 或者 push 之前，通过对文件的内容或目录的结构计算出一个 SHA-1哈希值，作为指纹字符串进行内容的校验，并将此结果作为数据的唯一标识和索引，在远处仓库接受到commit的文件之后，会再计算一遍哈希值然后跟传递过来的哈希值做比较，如果不一致，说明文件在传输时变得不完整，或者磁盘损坏导致文件数据损坏。**另外在 Git 数据库中的东西都是用此哈希值来作索引，而不是靠文件名**
* **Git 克隆一个完整项目的速度非常快，SVN 非常慢**
* **其中最重要的区别是在于Git 上的分支远比SVN上的强大**
  * 分支是什么
    * 在 SVN 这类的版本控制系统上，**分支是一个完整的目录，且这个目录拥有完整的实际文件**。如果工作成员想要开启新的分支，那将会影响“全世界”！每个人都会拥有和你一样的分支。如果你的分支是用来对系统模块进行安全检查测试的，那将会像传染病一样，你改一个分支，还得让其他人重新切分支重新下载，而且这些代码很可能对稳定版本还是具有破坏性的
    * 在 Git上，每个工作成员可以任意在自己的本地版本库开启无限个分支。完全不需担心妨碍其他工作成员。只要我不合并及提交到主要版本库，没有一个工作成员会被影响。等到我不需要这个分支时， 我只要把它从我的本地版本库删除即可
  * 什么时候需要创建一个分支
    * 我们在开发新的功能模块时，可能会遇到各种bug或者冲突，如果我们还在主分支上开发，万一冲突很严重，造成当前稳定版本的分支出问题，就会很麻烦。如果主分支始终保留着最新的稳定版本，在新的分支上开发，冲突严重时，最多也就是把当前分支删掉，从那个稳定分支重新分一支出来，这样处理起来就方便了，而且分支还可以保留开发中可能出现的各种bug方便修复但不影响主分支多的使用
    * 当我们需要切换分支，如切换到主分支时候，会保存当前分支的状态，以便日后继续开发，防止丢失开发进度



## Git的优点和缺点

### 优点

* Git 中每个克隆的版本库都是平等的。可以从任何一个版本库的克隆来创建属于自己的版本库，同时你的版本库也可以作为源提供给他人
* Git 的每一次提取操作，实际上都是一次对代码仓库的完整备份
* 提交完全在本地完成，无须别人给你授权，并且提交总是会成功
* Git 的提交不会被打断，直到你的工作完全满意了，PUSH给他人或者他人PULL你的版本库，合并会发生在PULL和PUSH过程中，不能自动解决的冲突会提示你手工完成

### 缺点

- Git 没有严格的权限管理控制，一般通过系统设置文件读写权限的方式来做权限控制。
- 工作目录只能是整个项目。比如 checkout，建分支，都是基于整个项目的。而 svn 可以基于项目中的某一个目录



## 安装Git

步骤很简单，不赘述了，安装完成后还需要最后一步设置，在 Git Bash 中输入

```
$ git config --global user.name "Your Name"
$ git config --global user.email "email@example.com"
```

因为Git是分布式版本控制系统，所以，每个机器都必须自报家门：你的名字和Email地址。如果有人故意冒充别人怎么办？这个不必担心，首先我们相信大家都是善良无知的群众，其次，真的有冒充的也是有办法可查的。注意git config 命令的 **--global** 参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址



## 版本库

### 什么是版本库

版本库又名仓库，英文名repository，可以简单理解成一个目录，这个目录里面的所有文件都可以被 Git 管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以还原



### 初始化版本库

```
$ git init
```



### 将文件添加到版本库

**1. 用命令把文件添加到仓库**

```
$ git add <file>
```

**2. 用命令把文件提交到仓库**

```
$ git commit -m "message"
```

**-m** 后面输入的是本次提交的说明，可以输入任意内容，当然最好是有意义的，这样你就能从历史记录里方便地找到改动记录



## 版本控制

### 版本库状态

* **`git status`**： 查看版本库当前状态
* **`git diff <file>`**： 查看文件修改的内容
* **`git log`**： 显示从最近到最远的提交日志
  * 可以加上**`--pretty=oneline`**参数，简洁显示



### 版本号

下面一大串类似乱码的就是**版本号（commit id）**，和SVN不一样，Git的commit id不是1，2，3递增的数字，而是**一个SHA-1计算出来的一个非常大的数字，用十六进制表示。**为什么commit id需要用这么一大串数字表示呢？因为Git是分布式的版本控制系统，多人在同一个版本库里工作，如果大家都用1，2，3……作为版本号，那肯定就冲突了

```
$ git log --pretty=oneline
1094adb7b9b3807259d8cb349e7df1d4d6477073 (HEAD -> master) append GPL
e475afc93c209a690c39c13a46716e8fa000c366 add distributed
eaadf4e385e865d25c48e7ca9c8395c3f7dfaef0 wrote a readme file
```



### 版本回退

#### reset

把当前版本回退到上一个版本，可以使用 **git reset** 命令。首先，Git必须知道当前版本是哪个版本，在Git中，**用HEAD表示当前版本**，上一个版本就是**HEAD^**，上上一个版本就是**HEAD^^**，当然往上100个版本写100个^比较容易数不过来，所以写成**HEAD~100**

```
$ git reset --hard HEAD^
```



#### reset的三种模式

| 模式          | HEAD的位置 | 索引   | 工作树 |
| ------------- | ---------- | ------ | ------ |
| soft          | 修改       | 不修改 | 不修改 |
| mixed（默认） | 修改       | 修改   | 不修改 |
| hard          | 修改       | 修改   | 修改   |

* 使用场合
  - mixed：复原修改过的索引的状态
  - hard：彻底取消最近的提交
  - soft：只取消提交



#### revert

用法同reset



#### reset 与 revert 的区别

* reset 是回到某次提交，提交及之前的commit都会被保留，但是此次之后的修改都会被退回到暂存区

* revert 是生成一个新的提交来撤销某次提交，此次提交之前的commit都会被保留



#### 回到未来的版本

Git 提供了一个命令 **git reflog** 用来记录每一次命令。**版本号没必要写全，前几位就可以了，Git会自动去找**

```
$ git reflog
$ git reset --hard <commit id>
```



### 工作区和暂存区

**工作区（Working Directory）**：就是在电脑里能看到的目录

**暂存区（stage）**：工作区有一个**隐藏目录 .git**，这个不算工作区，而是Git的版本库。Git的版本库里存了很多东西，其中最重要的就是**暂存区（stage 或 index）**，还有Git为我们**自动创建的第一个分支master**，以及**指向master的一个指针叫HEAD**



![0](Git.assets/0.jpg)



把文件往Git版本库里添加的时候，是分两步执行的

* 第一步是用 git add 把文件添加进去，实际上就是把文件修改添加到暂存区

* 第二步是用 git commit 提交更改，实际上就是把暂存区的所有内容提交到当前分支

因为在创建Git版本库时，Git自动为我们创建了唯一的 master 分支，所以现在 git commit 就是往master分支上提交更改。可以简单理解为，**需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改**



### 管理修改

为什么Git比其他版本控制系统设计得优秀，因为Git**跟踪并管理的是修改，而非文件**。

两次修改，第一次add，第二次没有add

> 第一次修改 -> git add -> 第二次修改 -> git commit

当用 git add 命令后，在工作区的第一次修改被放入暂存区，准备提交，但是，在工作区的第二次修改并没有放入暂存区，所以，git commit 只负责把暂存区的修改提交了，也就是第一次的修改被提交了，第二次的修改不会被提交。提交后，用以下命令可以查看工作区和版本库里面最新版本的区别

```
$ git diff HEAD -- <file>
```



### 撤销修改

* 把文件在工作区的修改全部撤销，这里有两种情况
  * 文件自修改后还没有被放到暂存区，**撤销修改就回到和版本库一模一样的状态**
  * 文件已经添加到暂存区后，又作了修改，**撤销修改就回到添加到暂存区后的状态**

总之，就是让这个文件回到最近一次 git commit 或 git add 时的状态

```
$ git checkout -- <file>
```

* 如果修改后已经使用 git add 到暂存区，用以下命令可以把暂存区的修改撤销掉，重新放回工作区，之后再用上面的命令撤销修改

```
$ git reset HEAD <file>
```



### 删除文件

* 确定要从版本库中删除该文件，用以下命令删掉，之后 commit

```
$ git rm <file>
$ git commit -m "message"
```

* 如果删错了，因为版本库里还保存着，所以可以很轻松地把误删的文件恢复到最新版本。git checkout 其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以还原

```
$ git checkout -- <file>
```



## 远程仓库

由于本地Git仓库和GitHub仓库之间的传输是通过 SSH 加密的，所以需要进行设置

**第1步：创建SSH Key**

在用户主目录下，看看有没有 .ssh 目录，如果有，再看看这个目录下有没有id_rsa和id_rsa.pub这两个文件，如果已经有了，可直接跳到下一步。如果没有，打开 Shell 或 Git Bash，创建 SSH Key

```
$ ssh-keygen -t rsa -C "email@example.com"
```

如果一切顺利的话，可以在用户主目录里找到 .ssh 目录，里面有 **id_rsa** 和 **id_rsa.pub** 两个文件，这两个就是SSH Key 的秘钥对，id_rsa 是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人

**第2步：登录GitHUB**

打开 SSH Keys 页面，然后点 Add SSH Key ，填上任意 Title，在 Key 文本框里粘贴 id_rsa.pub 文件的内容



**为什么GitHub需要SSH Key**

因为GitHub需要识别出你推送的提交确实是你推送的，而不是别人冒充的，而Git支持 SSH 协议，所以，GitHub只要知道了你的公钥，就可以确认只有你自己才能推送。**GitHub允许添加多个Key**。在GitHub上免费托管的Git仓库，任何人都可以看到，但只有你自己才能改。如果不想让别人看到Git库，有两个办法，一个是交点保护费，让GitHub把公开的仓库变成私有的。另一个办法是自己动手，搭一个Git服务器，因为是你自己的Git服务器，所以别人也是看不见的，相当简单，公司内部开发必备























